# 从递归入手二维动态规划

从递归到二维动态规划的过程。

二维动态规划的空间压缩技巧。

哪些递归不适合或者说没有必要改成动态规划？

**注意：**

二维动态规划问题非常多，不仅讲解067、讲解068涉及，整个系列课程会大量涉及【必备】课程后续会讲背包dp、区间dp、状压dp等等，依然包含大量二维动态规划问题

# 尝试过程

尝试函数有1个可变参数可以完全决定返回值，进而可以改出1维动态规划表的实现

同理尝试函数有2个可变参数可以完全决定返回值，那么就可以改出2维动态规划的实现

一维、二维、三维甚至多维动态规划问题，

大体过程都是：

1. 写出尝试递归
2. 记忆化搜索(从顶到底的动态规划)
3. 严格位置依赖的动态规划(从底到顶的动态规划)
4. 空间、时间的更多优化

# 如何规划

动态规划表的大小：**每个可变参数的可能性数量相乘**

动态规划方法的时间复杂度：**动态规划表的大小 * 每个格子的枚举代价**

二维动态规划依然需要去整理 **动态规划表的格子之间的依赖关系**

找寻依赖关系，往往 **通过画图来建立空间感**，使其更显而易见

然后依然是 **从简单格子填写到复杂格子** 的过程，即严格位置依赖的动态规划(从底到顶)

二维动态规划的压缩空间技巧原理不难，会了之后千篇一律

但是**不同题目依赖关系不一样**，需要 **很细心的画图来整理具体题目的依赖关系**

最后进行空间压缩的实现

# 如何改动态规划？

能改成动态规划的递归，统一特征：

**决定返回值的可变参数类型往往都比较简单，一般不会比int类型更复杂**。

为什么？从这个角度，可以解释 **带路径的递归（可变参数类型复杂）**，**不适合或者说没有必要改成动态规划**

题目2就是说明这一点的

一定要 **写出可变参数类型简单（不比int类型更复杂）**，并且 **可以完全决定返回值的递归**，

保证做到 **这些可变参数可以完全代表之前决策过程对后续过程的影响**！再去改动态规划！

不管几维动态规划

经常从递归的定义出发，**避免后续进行很多边界讨论**

这需要一定的经验来预知

# 题目：

## 最小路径和

题目1最小路径和给定一个包含非负整数的 m x n 网格 grid请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

测试链接 : https://leetcode.cn/problems/minimum-path-sum/

解题思路：

> ```
> 递归方法
> 如何来i，和 j位置？
> 1.题目定义好了，只能向左，或者向下，
> 2，所以 两个方向：
>   也就是说从上面，或者从左边来到i，j位置
>   左(i-1,j)，和上 (i,j-1)
> 所以递归套路：
>  对于当来到[i,j] 位置，那么，min，那么需要得到从哪里最小，那么比较上面，和左边，哪个最小。
>  
> ```



### 暴力递归版本：

```java
package algo.zuo.code67.dp;

import java.util.Arrays;

/**
 * 最小路径和
 * https://leetcode.cn/problems/minimum-path-sum/description/
 */
public class MinPathSum {


    public int minPathSum(int[][] grid) {
        return f1(grid, grid.length - 1, grid[0].length - 1);
    }

    // 递归方法
    // 如何来i，和 j位置？
    // 1.题目定义好了，只能向左，或者向下，
    // 2，所以 两个方向：
    //   也就是说从上面，或者从左边来到i，j位置
    //   左(i-1,j)，和上 (i,j-1)
    // 所以递归套路：
    private int f1(int[][] grid, int i, int j) {
        if (i == 0 && j == 0) return grid[0][0]; // base case
        int left = Integer.MAX_VALUE;
        int up = Integer.MAX_VALUE;
        if (i - 1 >= 0) // 第一行，
            left = f1(grid, i - 1, j);
        if (j - 1 >= 0) // 第一列
            up = f1(grid, i, j - 1);
        return Math.min(left, up) + grid[i][j];
    }

    // 傻缓存版本
    public int minPathSum2(int[][] grid) {
        int N = grid.length;  // N row
        int M = grid[0].length; // M col
        int[][] dp = new int[N][M];
        for (int i = 0; i < N; i++) {
            Arrays.fill(dp[i], -1);
        }
        dp[0][0] = grid[0][0]; // 填入第一个值
        return f2(grid, grid.length - 1, grid[0].length - 1, dp);
    }

    private int f2(int[][] grid, int i, int j, int[][] dp) {
        if (dp[i][j] != -1) return dp[i][j]; // 拿出从缓存
        int ans = 0;
        if (i == 0 && j == 0) ans = grid[0][0];
        else {
            int left = Integer.MAX_VALUE;
            int up = Integer.MAX_VALUE;
            if (i - 1 >= 0) // 第一行，
                left = f2(grid, i - 1, j, dp);
            if (j - 1 >= 0) // 第一列
                up = f2(grid, i, j - 1, dp);
            ans = Math.min(left, up) + grid[i][j];
        }
        dp[i][j] = ans;
        return ans;
    }
}
```

### 严格位置依赖

严格依赖位置版本，需要依次填入dp表中每一个位置。想象dp表，并根据当前给的条件依次填入。

**注意：一定要画出来dp每一个位置的值。**

```java
// 严格位置依赖的动态规划
// 想象有一个二维dp表，并依次填入dp表中每一个位置。
public int minPathSum3(int[][] grid) {
    int N = grid.length;  // N row
    int M = grid[0].length; // M col
    int[][] dp = new int[N][M];

    dp[0][0] = grid[0][0]; // 填入第一个值
    // 先填入第一行，因为第一行，只依赖左边的位置
    for (int i = 1; i < M; i++) {
        dp[0][i] = dp[0][i - 1] + grid[0][i];
    }
    // 先填入第一列，因为第一列，只依赖上边的位置
    for (int i = 1; i < N; i++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    }
    // 然后从 1，1位置开始到i，j位置
    for (int i = 1; i < N; i++) {
        for (int j = 1; j < M; j++) {
            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
    }
    return dp[N - 1][M - 1];
}
```

### 空间压缩技巧

使用一个一维的dp表即可完成表的更新，

原因：因为当得到想象中的dp中的一行之后，它上面的一行的数据已经不需要了。

当来到下一行之后，它只依赖左边的，和当前一行的。

如果想象不出来，一定要画出来。千万别偷懒。

```java
//空间压缩
public int minPathSum4(int[][] grid) {
    int N = grid.length;  // N row
    int M = grid[0].length; // M col
    int[] dp = new int[M];

    dp[0] = grid[0][0]; // 填入第一个值
    // 先填入第一行，因为第一行，只依赖左边的位置
    for (int i = 1; i < M; i++) {
        dp[i] = dp[i - 1] + grid[0][i];
    }
    // 然后从 1，1位置开始到i，j位置
    for (int i = 1; i < N; i++) {
        // i = 1，dp表变成想象中二维表的第1行的数据
        // i = 2，dp表变成想象中二维表的第2行的数据
        // ...
        // i = n-1，dp表变成想象中二维表的第n-1行的数据
        dp[0] += grid[i][0];
        for (int j = 1; j < M; j++) {
            dp[j] = Math.min(dp[j - 1], dp[j]) + grid[i][j];
        }
    }
    return dp[M - 1];
}
```



## 单词搜索（无法改成动态规划）

题目2单词搜索（无法改成动态规划）

给定一个 m x n 二维字符网格 board 和一个字符串单词 word

如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成

其中"相邻"单元格是那些水平相邻或垂直相邻的单元格

同一个单元格内的字母不允许被重复使用

测试链接 : https://leetcode.cn/problems/word-search/

```java
package algo.zuo.code67.dp;

/**
 * 单词搜索。
 * 不能改成动态规划的尝试，或者说没有必要改成动态规划。
 * 题目2
 * 单词搜索（无法改成动态规划）
 * 给定一个 m x n 二维字符网格 board 和一个字符串单词 word
 * 如果 word 存在于网格中，返回 true ；否则，返回 false 。
 * 单词必须按照字母顺序，通过相邻的单元格内的字母构成
 * 其中"相邻"单元格是那些水平相邻或垂直相邻的单元格
 * 同一个单元格内的字母不允许被重复使用
 * 测试链接 : https://leetcode.cn/problems/word-search/
 */
public class Code02_WordSearch {


    public boolean exist(char[][] board, String word) {
        char[] chars = word.toCharArray();
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (f5(board, i, j, chars, 0)) return true; //  从word中 0 位置开始。并且从board中的i，j，也就是任意位置开始
            }
        }
        return false;
    }

    // 此时网格中来到i，j位置，
    // 并且word中来到了k位置
    private boolean f5(char[][] board, int i, int j, char[] word, int k) {
        if (word.length == k) return true; // 单词来到了chars数组长度的位置，那么说明匹配到了
        if (i < 0 || i == board.length || j < 0 || j == board[0].length) return false; // 数据越界位置
        if (board[i][j] != word[k]) return false; // 没有越界，并且当前位置和k位置的数不同，那么结果为false
        char tmp = board[i][j];
        board[i][j] = '0';
        boolean f = f5(board, i + 1, j, word, k + 1) ||
                f5(board, i - 1, j, word, k + 1) ||
                f5(board, i, j + 1, word, k + 1) ||
                f5(board, i, j - 1, word, k + 1);
        board[i][j] = tmp; // 恢复现场，因为题目中要求，不能重复选
        return f;
    }
}
```

## 最长公共子序列

题目3最长公共子序列

给定两个字符串text1和text2

返回这两个字符串的最长 公共子序列 的长度

如果不存在公共子序列，返回0

两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列

测试链接 : https://leetcode.cn/problems/longest-common-subsequence/

```java
package algo.zuo.code67.dp;

import java.util.Arrays;

/**
 * 最长公共子序列
 * https://leetcode.cn/problems/longest-common-subsequence/
 */
public class Code03_LongestCommonSubsequence {

    public int longestCommonSubsequence(String text1, String text2) {
        char[] s1 = text1.toCharArray();
        char[] s2 = text2.toCharArray();
        return f1(s1, s2, s1.length - 1, s2.length - 1);
    }

    // 以i1，i2结尾最长子序列
    private int f1(char[] s1, char[] s2, int i1, int i2) {
        if (i1 < 0 || i2 < 0) return 0;
        int p1 = f1(s1, s2, i1 - 1, i2 - 1);    // s1，s2，都不要最后一个字符的情况
        int p2 = f1(s1, s2, i1 - 1, i2);          // s1，不要最后一个字符，s2要最后一个字符
        int p3 = f1(s1, s2, i1, i2 - 1);          // s1 要最后一个字符，s2不要
        int p4 = s1[i1] == s2[i2] ? p1 + 1 : 0;     // 当最后一个字符想等情况下，结果+1，并且继续走p1的情况
        return Math.max(Math.max(p1, p2), Math.max(p4, p3));
    }


    public int longestCommonSubsequence2(String text1, String text2) {
        char[] s1 = text1.toCharArray();
        char[] s2 = text2.toCharArray();
        return f2(s1, s2, s1.length, s2.length);
    }

    // 以长度从len1，和len2为基准的情况下，求最长子序列
    private int f2(char[] s1, char[] s2, int len1, int len2) {
        if (len1 == 0 || len2 == 0) return 0;
        int ans = 0;
        // s1和s2最后一个字符想等情况下
        if (s1[len1 - 1] == s2[len2 - 1]) ans = f2(s1, s2, len1 - 1, len2 - 1) + 1;
            // 最后一个字符不想等，那么求len1 -1 的情况下和len2 - 1的情况哪个最大
        else ans = Math.max(f2(s1, s2, len1 - 1, len2), f2(s1, s2, len1, len2 - 1));
        return ans;
    }

    // 以长度为基准的情况下，使用缓存版本
    public int longestCommonSubsequence3(String text1, String text2) {
        char[] s1 = text1.toCharArray();
        char[] s2 = text2.toCharArray();
        int N = s1.length;
        int M = s2.length;
        int[][] dp = new int[N + 1][M + 1];
        for (int i = 0; i < N + 1; i++) {
            Arrays.fill(dp[i], -1);
        }
        return f3(s1, s2, N, M, dp);
    }

    // 以长度从len1，和len2为基准的情况下，求最长子序列
    private int f3(char[] s1, char[] s2, int len1, int len2, int[][] dp) {
        if (len1 == 0 || len2 == 0) return 0;
        if (dp[len1][len2] != -1) return dp[len1][len2];
        int ans = 0;
        // s1和s2最后一个字符想等情况下
        if (s1[len1 - 1] == s2[len2 - 1]) ans = f3(s1, s2, len1 - 1, len2 - 1, dp) + 1;
            // 最后一个字符不想等，那么求len1 -1 的情况下和len2 - 1的情况哪个最大
        else ans = Math.max(f3(s1, s2, len1 - 1, len2, dp), f3(s1, s2, len1, len2 - 1, dp));
        dp[len1][len2] = ans;
        return ans;
    }

    // 严格位置动态规划
    public int longestCommonSubsequence4(String text1, String text2) {
        char[] s1 = text1.toCharArray();
        char[] s2 = text2.toCharArray();
        int N = s1.length + 1;
        int M = s2.length + 1;
        int[][] dp = new int[N][M];
        // 怎么依耐的，就是来到i，j位置的时候，它依耐，左上，上面，i-1和j-1的位置。
        // 从左往右，依次填入, 最开始0位置都是0，因为当任意一个长度为0的时候，最长公共子序列就是0
        for (int i = 1; i < N; i++) {
            for (int j = 1; j < M; j++) {
                if (s1[i - 1] == s2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[N - 1][M - 1];
    }


    // 严格位置依赖的动态规划 + 空间压缩
    public static int longestCommonSubsequence5(String str1, String str2) {
        char[] s1, s2;
        if (str1.length() >= str2.length()) {
            s1 = str1.toCharArray();
            s2 = str2.toCharArray();
        } else {
            s1 = str2.toCharArray();
            s2 = str1.toCharArray();
        }
        int n = s1.length;
        int m = s2.length;
        int[] dp = new int[m + 1];
        for (int len1 = 1; len1 <= n; len1++) {
            int leftUp = 0, backup;
            for (int len2 = 1; len2 <= m; len2++) {
                backup = dp[len2];
                if (s1[len1 - 1] == s2[len2 - 1]) {
                    dp[len2] = 1 + leftUp;
                } else {
                    dp[len2] = Math.max(dp[len2], dp[len2 - 1]);
                }
                leftUp = backup;
            }
        }
        return dp[m];
    }

}
```

## 最长回文子序列

题目4最长回文子序列给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度

测试链接 : https://leetcode.cn/problems/longest-palindromic-subsequence/



```java
package algo.zuo.code67.dp;


import java.util.Arrays;

// 最长回文子序列
// 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度
// 测试链接 : https://leetcode.cn/problems/longest-palindromic-subsequence/
public class Code04_LongestPalindromicSubsequence {


    public static int longestPalindromeSubseq1(String str) {
        char[] s = str.toCharArray();
        int n = s.length;
        return f1(s, 0, n - 1);
    }

    // 回文，【l】 = 【r】，那么要 长度+2，+ （l+1， r-1）
    // 不想等，那么求（l+1，r），或者（l，r-1）的最大
    private static int f1(char[] s, int l, int r) {
        if (l == r) return 1;
        if (l + 1 == r) return s[l] == s[r] ? 2 : 1; // 相邻两个字符想等 bb，
        if (s[l] == s[r]) return 2 + f1(s, l + 1, r - 1); // b …… b
        else return Math.max(f1(s, l + 1, r), f1(s, l, r - 1)); // b …… a
    }

    public static int longestPalindromeSubseq2(String str) {
        char[] s = str.toCharArray();
        int n = s.length;
        int[][] dp = new int[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dp[i], -1);
        }
        return f2(s, 0, n - 1, dp);
    }

    // 回文，【l】 = 【r】，那么要 长度+2，+ （l+1， r-1）
    // 不想等，那么求（l+1，r），或者（l，r-1）的最大
    private static int f2(char[] s, int l, int r, int[][] dp) {
        if (l == r) return 1;
        if (l + 1 == r) return s[l] == s[r] ? 2 : 1; // 相邻两个字符想等 bb，
        if (dp[l][r] != -1) return dp[l][r];
        int ans = 0;
        if (s[l] == s[r]) ans = 2 + f2(s, l + 1, r - 1, dp); // b …… b
        else ans = Math.max(f2(s, l + 1, r, dp), f2(s, l, r - 1, dp)); // b …… a
        dp[l][r] = ans;
        return ans;
    }

    public static int longestPalindromeSubseq3(String str) {
        char[] s = str.toCharArray();
        int n = s.length;
        int[][] dp = new int[n][n];
        for (int l = n - 1; l >= 0; l--) {
            dp[l][l] = 1;
            if (l + 1 < n) {
                dp[l][l + 1] = s[l] == s[l + 1] ? 2 : 1;
            }
            for (int r = l + 2; r < n; r++) {
                if (s[l] == s[r]) {
                    dp[l][r] = 2 + dp[l + 1][r - 1];
                } else {
                    dp[l][r] = Math.max(dp[l + 1][r], dp[l][r - 1]);
                }
            }
        }
        return dp[0][n - 1];
    }

    public static int longestPalindromeSubseq4(String str) {
        char[] s = str.toCharArray();
        int n = s.length;
        int[] dp = new int[n];
        for (int l = n - 1, leftDown = 0, backup; l >= 0; l--) {
            // dp[l] : 想象中的dp[l][l]
            dp[l] = 1;
            if (l + 1 < n) {
                leftDown = dp[l + 1];
                // dp[l+1] : 想象中的dp[l][l+1]
                dp[l + 1] = s[l] == s[l + 1] ? 2 : 1;
            }
            for (int r = l + 2; r < n; r++) {
                backup = dp[r];
                if (s[l] == s[r]) {
                    dp[r] = 2 + leftDown;
                } else {
                    dp[r] = Math.max(dp[r], dp[r - 1]);
                }
                leftDown = backup;
            }
        }
        return dp[n - 1];
    }
}
```



题目5节点数为n高度不大于m的二叉树个数现在有n个节点，计算出有多少个不同结构的二叉树满足节点个数为n且树的高度不超过m的方案因为答案很大，所以答案需要模上1000000007后输出

测试链接 : https://www.nowcoder.com/practice/aaefe5896cce4204b276e213e725f3ea

```java
package class067;

// 节点数为n高度不大于m的二叉树个数
// 现在有n个节点，计算出有多少个不同结构的二叉树
// 满足节点个数为n且树的高度不超过m的方案
// 因为答案很大，所以答案需要模上1000000007后输出
// 测试链接 : https://www.nowcoder.com/practice/aaefe5896cce4204b276e213e725f3ea
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下所有代码，把主类名改成Main，可以直接通过

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class Code05_NodenHeightNotLargerThanm {

    public static void main(String[] args) throws IOException {
       BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
       StreamTokenizer in = new StreamTokenizer(br);
       PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
       while (in.nextToken() != StreamTokenizer.TT_EOF) {
          int n = (int) in.nval;
          in.nextToken();
          int m = (int) in.nval;
          out.println(compute3(n, m));
       }
       out.flush();
       out.close();
       br.close();
    }

    public static int MAXN = 51;

    public static int MOD = 1000000007;

    // 记忆化搜索
    public static long[][] dp1 = new long[MAXN][MAXN];

    static {
       for (int i = 0; i < MAXN; i++) {
          for (int j = 0; j < MAXN; j++) {
             dp1[i][j] = -1;
          }
       }
    }

    // 二叉树节点数为n
    // 高度不能超过m
    // 结构数返回
    // 记忆化搜索
    public static int compute1(int n, int m) {
       if (n == 0) {
          return 1;
       }
       // n > 0
       if (m == 0) {
          return 0;
       }
       if (dp1[n][m] != -1) {
          return (int) dp1[n][m];
       }
       long ans = 0;
       // n个点，头占掉1个
       for (int k = 0; k < n; k++) {
          // 一共n个节点，头节点已经占用了1个名额
          // 如果左树占用k个，那么右树就占用i-k-1个
          ans = (ans + ((long) compute1(k, m - 1) * compute1(n - k - 1, m - 1)) % MOD) % MOD;
       }
       dp1[n][m] = ans;
       return (int) ans;
    }

    // 严格位置依赖的动态规划
    public static long[][] dp2 = new long[MAXN][MAXN];

    public static int compute2(int n, int m) {
       for (int j = 0; j <= m; j++) {
          dp2[0][j] = 1;
       }
       for (int i = 1; i <= n; i++) {
          for (int j = 1; j <= m; j++) {
             dp2[i][j] = 0;
             for (int k = 0; k < i; k++) {
                // 一共i个节点，头节点已经占用了1个名额
                // 如果左树占用k个，那么右树就占用i-k-1个
                dp2[i][j] = (dp2[i][j] + dp2[k][j - 1] * dp2[i - k - 1][j - 1] % MOD) % MOD;
             }
          }
       }
       return (int) dp2[n][m];
    }

    // 空间压缩
    public static long[] dp3 = new long[MAXN];

    public static int compute3(int n, int m) {
       dp3[0] = 1;
       for (int i = 1; i <= n; i++) {
          dp3[i] = 0;
       }
       for (int j = 1; j <= m; j++) {
          // 根据依赖，一定要先枚举列
          for (int i = n; i >= 1; i--) {
             // 再枚举行，而且i不需要到达0，i>=1即可
             dp3[i] = 0;
             for (int k = 0; k < i; k++) {
                // 枚举
                dp3[i] = (dp3[i] + dp3[k] * dp3[i - k - 1] % MOD) % MOD;
             }
          }
       }
       return (int) dp3[n];
    }

}
```



## 最长递增路径

题目6矩阵中的最长递增路径给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度.

对于每个单元格，你可以往上，下，左，右四个方向移动不能在对角线方向上移动或移动到边界外（即不允许环绕）

测试链接 : https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/



```java
package algo.zuo.code67.dp;


// 矩阵中的最长递增路径
// 给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度
// 对于每个单元格，你可以往上，下，左，右四个方向移动
// 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）
// 测试链接 : https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/
public class Code06_LongestIncreasingPath {


    public int longestIncreasingPath(int[][] matrix) {
        int n = matrix.length;
        int m = matrix[0].length;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                ans = Math.max(ans, f1(matrix, i, j));
            }
        }
        return ans;
    }

    // 边界条件：
    // cur 要小于下一个位置的数，
    // 只要不越界就行，那么需要判断四个位置，上下，左右，都不能越界
    private int f1(int[][] matrix, int i, int j) {
        int l = 0, r, u = 0, d = 0;
        int cur = matrix[i][j];
        int ans = 0;
        if (i - 1 >= 0 && cur < matrix[i - 1][j]) {
            l = f1(matrix, i - 1, j);
            ans = Math.max(ans, l);
        }
        if (i + 1 < matrix.length && cur < matrix[i + 1][j]) {
            r = f1(matrix, i + 1, j);
            ans = Math.max(ans, r);
        }
        if (j - 1 >= 0 && cur < matrix[i][j - 1]) {
            u = f1(matrix, i, j - 1);
            ans = Math.max(ans, u);
        }
        if (j + 1 < matrix[0].length && cur < matrix[i][j + 1]) {
            d = f1(matrix, i, j + 1);
            ans = Math.max(ans, d);
        }
        return ans + 1;
    }

    public int longestIncreasingPath2(int[][] matrix) {
        int n = matrix.length;
        int m = matrix[0].length;
        int ans = 0;
        int[][] dp = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                ans = Math.max(ans, f2(matrix, i, j, dp));
            }
        }
        return ans;
    }

    private int f2(int[][] matrix, int i, int j, int[][] dp) {
        if (dp[i][j] != 0) return dp[i][j]; // 从缓存中拿出来
        int cur = matrix[i][j];
        int ans = 0;
        if (i - 1 >= 0 && cur < matrix[i - 1][j]) {
            ans = Math.max(ans, f2(matrix, i - 1, j, dp));
        }
        if (i + 1 < matrix.length && cur < matrix[i + 1][j]) {
            ans = Math.max(ans, f2(matrix, i + 1, j, dp));
        }
        if (j - 1 >= 0 && cur < matrix[i][j - 1]) {
            ans = Math.max(ans, f2(matrix, i, j - 1, dp));
        }
        if (j + 1 < matrix[0].length && cur < matrix[i][j + 1]) {
            ans = Math.max(ans, f2(matrix, i, j + 1, dp));
        }
        dp[i][j] = ans + 1;
        return ans + 1;
    }
}
```



